# æœåŠ¡ç«¯ä½¿ç”¨æç¤º

## è¿æ¥ç®¡ç†å»ºè®®
```csharp
public class KcpServer
{
    private readonly ConcurrentDictionary<uint, KcpConnection> _connections = new();
    private readonly ConcurrentDictionary<uint, Task> _connectionWorkers = new();
    private readonly KcpHealthyChecker _healthyChecker = new();
    private readonly UdpClient _udpServer;
    
    public async Task RunAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var result = await _udpServer.ReceiveAsync(ct);
            
            // 1. åˆ¤æ–­æ•°æ®åŒ…ç±»å‹ï¼ˆæ¡æ‰‹åŒ…/æ•°æ®åŒ…/å¥åº·æ£€æŸ¥åŒ…ï¼‰
            if (IsHandshakePacket(result.Buffer))
            {
                // 2. å¤„ç†æ¡æ‰‹ï¼Œåˆ†é…å”¯ä¸€conv
                uint conv = AllocateConnectionId();
                var connection = new KcpConnection(_udpServer, conv, result.RemoteEndPoint);
                
                // 3. å¯åŠ¨è¿æ¥ç®¡ç†
                _connectionWorkers.TryAdd(conv, connection.RunReceiveLoop(ct));
                _connections.TryAdd(conv, connection);
                
                // 4. å‘é€æ¡æ‰‹å“åº”
                SendHandshakeResponse(conv, result.RemoteEndPoint);
            }
            else if (IsHealthCheckPacket(result.Buffer))
            {
                uint conv = ExtractConvFromPacket(result.Buffer);
                if (_connections.TryGetValue(conv, out var _))
                {
					// æ£€æŸ¥WorkerçŠ¶æ€ï¼Œä¾‹å¦‚æ˜¯å¦å‡ºç°å¼‚å¸¸åœæ­¢æˆ–æ­£å¸¸é€€å‡º
					// ...
					
					// æ ‡è®°å­˜æ´»çŠ¶æ€
                     _healthyChecker.PingReceived(conv);
                }
            }
            else
            {
                // 5. æ•°æ®åŒ…ï¼šæå–convå¹¶è½¬å‘åˆ°å¯¹åº”è¿æ¥
                uint conv = ExtractConvFromPacket(result.Buffer);
                if (_connections.TryGetValue(conv, out var conn))
                {
                    // æ£€æŸ¥ï¼Œå¹¶åœ¨å¿…è¦æ—¶æ›´æ–°è¿æ¥RemoteEndPoint
                    if (!conn.RemoteEndpoint.Equals(result.RemoteEndPoint))
                    {
                        LogInfo($"è¿æ¥ {conv} ç«¯ç‚¹å˜æ›´: {conn.RemoteEndpoint} -> {result.RemoteEndPoint}");
                        conn.RemoteEndpoint = result.RemoteEndPoint;
                        _healthyChecker.UpdateEndpoint(conv, result.RemoteEndPoint);
                    }
                    
                    // ç„¶åå°†æ•°æ®ä¼ é€’ç»™è¿æ¥
                    var inputResult = conn.ManualInputOnce(result);
                    
                    if (inputResult.IsFailed)
                    {
                        HandleInputFailure(conv, inputResult, result.RemoteEndPoint);
                    }
                    
                    // è®°å½•è¿æ¥æ´»åŠ¨æ—¶é—´
                    _healthyChecker.RecordActivity(conv);
                }
            }
        }
    }
    
    private void HandleInputFailure(uint conv, KcpInputResult inputResult, IPEndPoint remoteEndPoint)
    {
        switch (inputResult.RawResult)
        {
            case -1:  // æ•°æ®åŒ…é•¿åº¦ä¸è¶³
                LogWarning($"è¿æ¥ {conv} ({remoteEndPoint}) æ¥æ”¶æ•°æ®ä¸å®Œæ•´");
                break;
            case -2:  // convæ ‡è¯†ç¬¦ä¸åŒ¹é…
                LogWarning($"è¿æ¥ {conv} ({remoteEndPoint}) æ ‡è¯†ç¬¦ä¸åŒ¹é…");
                // ä¸¥é‡é”™è¯¯ï¼Œæ–­å¼€è¿æ¥
                if (_connections.TryRemove(conv, out var conn))
                {
                    conn.Dispose();
                    LogInfo($"å·²æ–­å¼€è¿æ¥ {conv} (æ ‡è¯†ç¬¦ä¸åŒ¹é…)");
                }
                break;
            case -3:  // æ„æ–™å¤–çš„CMDå‘½ä»¤
                LogWarning($"è¿æ¥ {conv} ({remoteEndPoint}) æ”¶åˆ°æ— æ•ˆå‘½ä»¤");
                break;
        }
    }
}
```

## æœåŠ¡ç«¯æ¶æ„é€‰é¡¹

### é€‰é¡¹1ï¼šå…±äº«UdpClientï¼ˆéœ€è¦è·¯ç”±é€»è¾‘ï¼‰
```csharp
// ä¼˜ç‚¹ï¼šèµ„æºä½¿ç”¨å°‘
// ç¼ºç‚¹ï¼šéœ€è¦è§£æåŒ…å¤´å¹¶è·¯ç”±åˆ°æ­£ç¡®è¿æ¥
// é€‚ç”¨ï¼šè¿æ¥æ•°å°‘ï¼Œæ€§èƒ½è¦æ±‚ä¸é«˜

// å¦‚ä¸Šé¢çš„KcpServerç¤ºä¾‹ï¼Œä½¿ç”¨ManualInputOnceæ‰‹åŠ¨è·¯ç”±
```

### é€‰é¡¹2ï¼šæ¯ä¸ªè¿æ¥ç‹¬ç«‹UdpClient
```csharp
// ä¼˜ç‚¹ï¼šç®€å•ï¼Œæ— è·¯ç”±é€»è¾‘
// ç¼ºç‚¹ï¼šæ¯ä¸ªè¿æ¥å ç”¨ä¸€ä¸ªç«¯å£
// é€‚ç”¨ï¼šè¿æ¥æ•°å¯æ§ï¼Œéœ€è¦ç®€å•å®ç°

public class SimpleKcpServer
{
    public async Task HandleClientAsync(UdpClient client, IPEndPoint clientEndpoint, CancellationToken ct)
    {
        uint conv = AllocateConnectionId();
        var connection = new KcpConnection(client, conv, clientEndpoint);
        
        // ä½¿ç”¨ReceiveOnceAsyncè‡ªåŠ¨æ¨¡å¼
        await RunKcpWorkerAsync(connection, ct);
    }
}
```

### é€‰é¡¹3ï¼šæ··åˆæ–¹æ¡ˆ
```csharp
// ä¸»ç›‘å¬ç«¯å£æ¥æ”¶æ¡æ‰‹åŒ…
// æ¡æ‰‹æˆåŠŸååˆ†é…æ–°ç«¯å£åˆ›å»ºä¸“ç”¨è¿æ¥
// ä¼˜ç‚¹ï¼šå¹³è¡¡èµ„æºä½¿ç”¨å’Œå¤æ‚æ€§
// ç¼ºç‚¹ï¼šå®ç°å¤æ‚ï¼Œéœ€è¦ç«¯å£ç®¡ç†

public class HybridKcpServer
{
    private readonly UdpClient _mainListener;
    private readonly PortPool _portPool;
    
    public async Task RunAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var result = await _mainListener.ReceiveAsync(ct);
            
            if (IsHandshakePacket(result.Buffer))
            {
                // åˆ†é…æ–°ç«¯å£
                int port = _portPool.GetNextPort();
                var dedicatedClient = new UdpClient(port);
                
                // å¯åŠ¨ä¸“ç”¨è¿æ¥
                _ = HandleDedicatedConnection(dedicatedClient, result.RemoteEndPoint, ct);
                
                // å‘é€æ¡æ‰‹å“åº”ï¼ˆåŒ…å«æ–°ç«¯å£ä¿¡æ¯ï¼‰
                SendHandshakeResponseWithPort(result.RemoteEndPoint, port);
            }
        }
    }
}
```

## æ³¨æ„äº‹é¡¹
1. **convåˆ†é…**ï¼šç¡®ä¿æ¯ä¸ªå®¢æˆ·ç«¯è·å¾—å”¯ä¸€çš„convï¼ˆconnection idï¼‰
2. **è¿æ¥æ¸…ç†**ï¼šå®ç°å¿ƒè·³æˆ–è¶…æ—¶æœºåˆ¶ï¼Œæ¸…ç†å¤±æ•ˆè¿æ¥
3. **èµ„æºé™åˆ¶**ï¼šé™åˆ¶æœ€å¤§å¹¶å‘è¿æ¥æ•°ï¼Œé˜²æ­¢èµ„æºè€—å°½
4. **UDPå¤ç”¨**ï¼šå•ä¸ªUdpClientæœåŠ¡å¤šä¸ªè¿æ¥æ—¶ï¼Œéœ€è¦è§£æåŒ…å¤´å¹¶è·¯ç”±åˆ°æ­£ç¡®è¿æ¥

**å‚è€ƒå®ç°**ï¼šå¯å‚è€ƒ [neuecc/kcp](https://github.com/neuecc/kcp) ä¸­çš„è¿æ¥ç®¡ç†å’Œæ¡æ‰‹åè®®è®¾è®¡ã€‚
---
æœ¬æ–‡å®Œå…¨ç”±äººå·¥ç¼–å†™ï¼Œæ²¡æœ‰æœºå™¨äººå‚ä¸ğŸ¤–
IPï¼šç”ŸåŒ–æ–¯å¦