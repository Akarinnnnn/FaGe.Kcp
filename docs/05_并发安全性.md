# 并发安全性

## 线程安全级别

**重要**：FaGe.Kcp 的并发安全性有限，大多数核心方法**不是线程安全的**。这是为了性能和实现简易做出的设计权衡。

| 方法 | 并发安全性 | 风险说明 |
|------|-----------|----------|
| `SendAsync()` | ❌ 不安全 | 通过`QueueToSenderWithAsyncSource()`操作非线程安全的`snd_queue` |
| `ReceiveAsync()` | ❌ 不安全 | 底层`TryReadPacket()`操作非线程安全的`rcv_queue`，且`pendingReceiveTaskSource`存在竞争条件 |
| `UpdateAsync()` | ❌ 不安全 | 无任何同步措施，会修改内部连接状态（snd_queue、rcv_queue等） |
| `FlushAsync()` | ❌ 不安全 | 修改内部缓冲区状态 |
| `InputFromUnderlyingTransport()` | ❌ 不安全 | 修改接收队列和缓冲区 |
| `ReceiveOnceAsync()` | ❌ 不安全 | 调用`InputFromUnderlyingTransport()`，同样修改内部状态 |

## 有限支持的模式
- **`TryReadPacket()`**：有限支持多消费者，但必须保证顺序：`A读取包1 → A释放 → B读取包2 → B释放`
- **内部集合**：所有未使用`Concurrent`前缀的集合（`Queue<T>`、`LinkedList<T>`）均无同步机制

## 推荐的使用模式

### ✅ 正确模式：专用异步工作器（推荐）
```csharp
public async Task KcpWorkerAsync(
    KcpConnection connection,
    Channel<byte[]> sendChannel,
    CancellationToken ct)
{
    Task? udpReceiveTask = null;
    
    while (!ct.IsCancellationRequested)
    {
        try
        {
            // --- 阶段1：UDP输入处理 ---
            if (udpReceiveTask?.IsCompleted ?? false)
            {
                await udpReceiveTask.ConfigureAwait(false); // 处理到达的数据
                udpReceiveTask = null;
            }
            
            if (udpReceiveTask == null)
            {
                // 启动新的非阻塞接收
                udpReceiveTask = connection.ReceiveOnceAsync(ct);
            }
            
            // --- 阶段2：KCP状态更新 ---
            uint timestamp = (uint)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            await connection.UpdateAsync(timestamp, ct).ConfigureAwait(false);
            
            // --- 阶段3：发送队列处理 ---
            while (sendChannel.Reader.TryRead(out var data))
            {
                await connection.SendAsync(data, ct).ConfigureAwait(false);
            }
            
            // --- 阶段4：应用数据接收 ---
            var packet = connection.TryReadPacket(ct);
            
            if (packet.IsNotEmpty)
            {
                ProcessData(packet.Result.Buffer);
                packet.Dispose();
            }
            
            // --- 阶段5：循环控制 ---
            // 根据是否有工作来动态调整等待时间
            bool hadWork = sendChannel.Reader.Count > 0;
            await Task.Delay(hadWork ? 1 : 10, ct).ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            // 正常退出
            break;
        }
        catch (Exception ex)
        {
            // 记录错误，但继续运行（除非是致命错误）
            LogError($"KCP工作器错误: {ex.Message}");
            await Task.Delay(100, ct).ConfigureAwait(false); // 错误退避
        }
    }
}
```

## ReceiveOnceAsync() 的重要特性

### 1. 非幂等性
每个`ReceiveOnceAsync()`调用处理一个数据包，多次调用会处理不同的数据包。

### 2. 异步阻塞性
`ReceiveOnceAsync()`会等待直到有数据到达或取消，是异步阻塞操作。

### 3. 顺序敏感性
必须按顺序处理`ReceiveOnceAsync()`调用结果，避免多个未完成的调用导致数据包处理顺序错误。

## 已知的竞争条件

### 1. pendingReceiveTaskSource 竞争
```csharp
// 在 ReceiveAsyncBase 中：
pendingReceiveTaskSource = signalSource;

// 如果两个线程同时调用 ReceiveAsync()：
// 线程A: 设置 pendingReceiveTaskSource = sourceA
// 线程B: 设置 pendingReceiveTaskSource = sourceB （覆盖A）
// 结果：线程A的 TaskCompletionSource 可能永远无法完成
```

### 2. 集合操作竞争
```csharp
// 同时调用 SendAsync() 和 UpdateAsync()：
// SendAsync: snd_queue.Enqueue(packet)
// UpdateAsync: snd_queue.TryDequeue(out packet) // 可能同时发生，导致异常
```

### 3. ReceiveOnceAsync 并发调用竞争
```csharp
// 同时启动多个 ReceiveOnceAsync() 调用：
// 调用1: 开始接收数据包A
// 调用2: 开始接收数据包B
// 问题：两个调用可能并发修改内部状态，且数据包处理顺序不确定
```

### 4. Dispose与其他操作的竞争
```csharp
// 线程A: await connection.SendAsync(data, ct);
// 线程B: connection.Dispose();  // 可能立即触发ObjectDisposedException

// 解决方案：使用CancellationToken协调
// 所有操作都检查同一个CancellationToken（或至少链接至这个Token）
// Dispose前取消该token
```

## 异常处理原则

### 策略总结

| 异常类型 | 处理方式 | 理由 |
|---------|---------|------|
| `OperationCanceledException` (已知来源ct触发) | 捕获并`break` | 正常退出流程 |
| `SocketException` (超时/连接重置/网络变化等临时错误) | 捕获并继续 | 网络临时问题，可恢复 |
| `ObjectDisposedException` (取消时) | 捕获并`break` | 资源清理期间的预期异常 |
| **其他所有异常** | **不捕获，传播出去** | **让调用者感知严重错误** |

### 为什么让异常流出工作器？

1. **调用者知情权**：调用者需要知道工作器是否因错误退出
2. **监控和告警**：外部系统可以监控工作器故障
3. **资源管理**：如果工作器因异常退出，可能需要重建连接
4. **调试信息**：完整的异常堆栈有助于问题诊断

## 性能与安全权衡

FaGe.Kcp 设计时的权衡：

1. **性能优先**：使用标准集合而非并发集合，减少锁开销
2. **简单性**：避免复杂的同步逻辑，简化代码结构
3. **明确责任**：将并发安全的责任交给使用者，提供灵活性。但代价是提高了编写门槛
4. **异步友好**：移除后台循环，完全拥抱async/await模式

## 最佳实践总结

1. **每个连接使用专用异步工作器**（如`KcpWorkerAsync`模式）
2. **使用"检查-等待-清空"模式管理`ReceiveOnceAsync()`调用**
3. **避免任何形式的并发方法调用**同一个连接实例
4. **让严重异常流出工作器**，使调用者能够感知和处理
5. **谨慎使用`ConfigureAwait(false)`**：
   - ✅ **推荐在**：控制台应用、ASP.NET Core应用、后台服务、库代码中使用
   - ⚠️ **避免在**：ASP.NET（而不是Core）、WPF/WinForms UI线程等需要同步上下文的环境中盲目使用
   - **原则**：如果代码需要回到原始上下文（如更新UI、操作ASP.NET HttpContext），不要使用`ConfigureAwait(false)`
6. **正确处理异步异常**：
   ```csharp
   // ✅ 正确：保留原始异常堆栈
   try
   {
       await workerTask; // 异步等待获得原始异常
       // workerTask.GetAwaiter().GetResult(); // 同步处理Task的推荐方式，可抛出原始异常
       // ProcessAggreatedException(workerTask.Exception); // 检视AggreatedException，适合需要AggreatedException的场合
   }
   catch (Exception ex)
   {
       // ex包含完整的异步调用堆栈
   }
   ```
7. **服务端使用连接池**，每个连接有独立的异步工作器
8. **通过Task状态监控工作器健康**（`IsFaulted`、`Status`属性）
---
本文完全由人工编写，没有机器人参与🤖
IP：生化斯坦