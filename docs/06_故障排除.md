# æ•…éšœæ’é™¤

## å¹¶å‘ç›¸å…³é—®é¢˜

### Q1: å¤šä¸ªçº¿ç¨‹è°ƒç”¨SendAsync()å¯¼è‡´æ•°æ®æ··ä¹±æˆ–å´©æºƒ
**ç°è±¡**ï¼šæ•°æ®åŒ…ä¸¢å¤±ã€é¡ºåºé”™ä¹±ã€å¶å°”æŠ›å‡º`InvalidOperationException`

**åŸå› **ï¼š`snd_queue`æ˜¯éçº¿ç¨‹å®‰å…¨çš„`Queue<PacketBuffer>`ï¼Œå¤šçº¿ç¨‹å¹¶å‘è®¿é—®å¯¼è‡´ç«äº‰æ¡ä»¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **ä½¿ç”¨ä¸“ç”¨å·¥ä½œå™¨æ¨¡å¼**ï¼šæ‰€æœ‰å‘é€æ“ä½œé€šè¿‡å•ä¸€å·¥ä½œçº¿ç¨‹è¿›è¡Œ
2. **ä½¿ç”¨Channelå®ç°çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—**ï¼š
   ```csharp
   private readonly Channel<ReadOnlyMemory<byte>> _sendChannel = Channel.CreateUnbounded<ReadOnlyMemory<byte>>();
   
   // å¤šçº¿ç¨‹å®‰å…¨å‘é€
   public ValueTask SendThreadSafeAsync(ReadOnlyMemory<byte> data, CancellationToken ct)
       => _sendChannel.Writer.WriteAsync(data, ct);
   
   // åœ¨å·¥ä½œå™¨ä¸­å¤„ç†å‘é€
   await foreach (var data in _sendChannel.ReadToEndAsync())
   {
       await _connection.SendAsync(data, ct);
   }
   ```

### Q2: ReceiveAsync()è¢«æ°¸ä¹…é˜»å¡
**ç°è±¡**ï¼š`ReceiveAsync()`è°ƒç”¨æ°¸ä¸è¿”å›ï¼Œå³ä½¿æœ‰æ•°æ®åˆ°è¾¾

**åŸå› **ï¼š`pendingReceiveTaskSource`è¢«å…¶ä»–çº¿ç¨‹è¦†ç›–ï¼Œå¯¼è‡´TaskCompletionSourceæ— æ³•å®Œæˆ

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **ç¡®ä¿å•æ¶ˆè´¹è€…**ï¼šåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª`ReceiveAsync()`è°ƒç”¨åœ¨ç­‰å¾…
2. **ä½¿ç”¨è¶…æ—¶å–æ¶ˆæœºåˆ¶**ï¼š
   ```csharp
   try
   {
       CancellationToken ct = GetTimeoutCancellableToken(); // è·å–è¶…æ—¶å–æ¶ˆçš„CancellationToken
       var packet = await connection.ReceiveAsync(ct);
       // å¤„ç†æ•°æ®åŒ…
   }
   catch (TimeoutException)
   {
       // è¶…æ—¶å¤„ç†ï¼šè®°å½•æ—¥å¿—æˆ–é‡è¯•
   }
   ```
3. **æ£€æŸ¥å·¥ä½œå™¨è®¾è®¡**ï¼šç¡®ä¿æ¥æ”¶æ“ä½œåœ¨ä¸“ç”¨å·¥ä½œä»»åŠ¡ä¸­é¡ºåºæ‰§è¡Œ

### Q3: ReceiveOnceAsync()è°ƒç”¨å¯¼è‡´æ•°æ®åŒ…ä¸¢å¤±
**ç°è±¡**ï¼šéƒ¨åˆ†UDPæ•°æ®åŒ…æœªè¢«KCPå¤„ç†ï¼Œç›´æ¥ä¸¢å¤±

**åŸå› **ï¼šå¤šä¸ªæœªå®Œæˆçš„`ReceiveOnceAsync()`è°ƒç”¨ç«äº‰æ¥æ”¶æ•°æ®åŒ…

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **ä½¿ç”¨"æ£€æŸ¥-ç­‰å¾…-æ¸…ç©º"æ¨¡å¼**ï¼š
   ```csharp
   Task? udpReceiveTask = null; // å­—æ®µï¼Œæˆ–å¼‚æ­¥æ–¹æ³•çš„å±€éƒ¨å˜é‡
   
   if (udpReceiveTask?.IsCompleted ?? false)
   {
       await udpReceiveTask; // å¤„ç†å·²åˆ°è¾¾çš„æ•°æ®
       udpReceiveTask = null;
   }
   
   if (udpReceiveTask == null)
   {
       udpReceiveTask = connection.ReceiveOnceAsync(ct);
   }
   ```
2. **é¿å…å¹¶å‘è°ƒç”¨**ï¼šç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª`ReceiveOnceAsync()`åœ¨è¿›è¡Œä¸­

## æ€§èƒ½ç›¸å…³é—®é¢˜

### Q4: CPUä½¿ç”¨ç‡è¿‡é«˜
**ç°è±¡**ï¼šKCPå·¥ä½œå™¨å ç”¨å¤§é‡CPUæ—¶é—´

**åŸå› **ï¼šå·¥ä½œå™¨å¾ªç¯æ²¡æœ‰é€‚å½“çš„å»¶è¿Ÿï¼ŒæŒç»­ç©ºè½¬

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// æ·»åŠ é€‚å½“å»¶è¿Ÿ
await Task.Delay(10, ct).ConfigureAwait(false);

// æˆ–è€…æ ¹æ®å·¥ä½œè´Ÿè½½åŠ¨æ€è°ƒæ•´
bool hadWork = /* æ£€æŸ¥æ˜¯å¦æœ‰å·¥ä½œå¤„ç† */;
await Task.Delay(hadWork ? 1 : 10, ct).ConfigureAwait(false);
```

**æ¨èå»¶è¿Ÿæ—¶é—´**ï¼š
- å®æ—¶åº”ç”¨ï¼š5-10ms
- ä¸€èˆ¬åº”ç”¨ï¼š10-20ms  
- ä½åŠŸè€—åœºæ™¯ï¼š20-50ms

### Q5: å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
**ç°è±¡**ï¼šåº”ç”¨å†…å­˜ä¸æ–­å¢é•¿ï¼Œæœ€ç»ˆå¯èƒ½è€—å°½

**åŸå› **ï¼š
1. `KcpApplicationPacket`æœªåŠæ—¶é‡Šæ”¾
2. å‘é€é˜Ÿåˆ—ç§¯å‹æœªå¤„ç†
3. å†…éƒ¨ç¼“å†²åŒºæœªå›æ”¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **ç¡®ä¿æ•°æ®åŒ…é‡Šæ”¾**ï¼š
   ```csharp
   var packet = await connection.ReceiveAsync(ct);
   try
   {
       ProcessData(packet.Result.Buffer);
   }
   finally
   {
       packet.Dispose(); // å…³é”®ï¼
   }
   ```
2. **ç›‘æ§å‘é€é˜Ÿåˆ—**ï¼š
   ```csharp
   if (connection.PacketPendingSentCount > 300)
   {
       // å‘é€é˜Ÿåˆ—ç§¯å‹ï¼Œè€ƒè™‘é™æµæˆ–å¢å¤§çª—å£
       LogWarning($"å‘é€é˜Ÿåˆ—ç§¯å‹: {connection.PacketPendingSentCount}");
   }
   ```

### Q6: KcpApplicationPacketå¤šé‡é‡Šæ”¾å¯¼è‡´æ•°æ®é”™ä¹±
**ç°è±¡**ï¼šåç»­æ¥æ”¶çš„æ•°æ®åŒ…å†…å®¹ä¸æ­£ç¡®æˆ–æŠ›å‡ºå¼‚å¸¸

**åŸå› **ï¼š`KcpApplicationPacket`æ˜¯å€¼ç±»å‹ï¼Œå¤åˆ¶åå¤šä¸ªå®ä¾‹å…±äº«å†…éƒ¨ç¼“å†²åŒºå¼•ç”¨ã€‚æå‰é‡Šæ”¾ä¼šå½±å“åç»­æ•°æ®åŒ…ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
// âŒ é”™è¯¯ï¼šå¤åˆ¶å€¼ç±»å‹å¯¼è‡´å¤šé‡å¼•ç”¨
var packet1 = await connection.ReceiveAsync(ct);
var packet2 = packet1; // æµ…æ‹·è´ï¼

// âœ… æ­£ç¡®ï¼šç«‹å³ä½¿ç”¨æˆ–åˆ›å»ºæ·±æ‹·è´
var packet = await connection.ReceiveAsync(ct);
if (packet.IsNotEmpty)
{
    // æ–¹æ¡ˆ1ï¼šç«‹å³ä½¿ç”¨å¹¶é‡Šæ”¾
    var data = packet.Result.Buffer;
    ProcessData(data);
    packet.Dispose();
    
    // æ–¹æ¡ˆ2ï¼šéœ€è¦æŒä¹…åŒ–æ—¶åˆ›å»ºå‰¯æœ¬
    // byte[] copy = packet.Result.Buffer.ToArray();
    // packet.Dispose();
    // // ä½¿ç”¨copy
}
```

### Q7: SendAsyncè¿”å›ç©ºç»“æœä½†æ•°æ®å·²æ’é˜Ÿ
**ç°è±¡**ï¼š`SendAsync`ç«‹å³è¿”å›æˆåŠŸä½†`sentCount`ä¸º0

**åŸå› **ï¼šåœ¨æµæ¨¡å¼ä¸‹ï¼Œæ•°æ®è¢«åˆå¹¶åˆ°å‰ä¸€ä¸ªåˆ†ç‰‡åŒ…ä¸­ï¼Œæ²¡æœ‰åˆ›å»ºæ–°åŒ…

**è§£å†³æ–¹æ¡ˆ**ï¼š
```csharp
var result = await connection.SendAsync(data, ct);
if (result.IsSucceed)
{
    // åªè¦æœ‰å®é™…æ•°æ®ï¼Œå³ä½¿SentCountä¸º0ï¼Œä¹Ÿå·²æˆåŠŸæ’é˜Ÿã€‚å¯ä»¥å¿½ç•¥è¿™ä¸ªå€¼
    // æˆ‘è®¤ä¸ºè¿™æ˜¯æ½œåœ¨çš„ï¼Œä¸åŸå§‹å®ç°çš„è¡Œä¸ºä¸ä¸€è‡´çš„bugï¼Œåç»­ç‰ˆæœ¬å¯èƒ½ä¼šæ›´æ”¹è¡Œä¸º
}
```

## ç½‘ç»œç›¸å…³é—®é¢˜

### Q8: è¿æ¥é¢‘ç¹æ–­å¼€æˆ–è¶…æ—¶
**ç°è±¡**ï¼šè¿æ¥ä¸ç¨³å®šï¼Œç»å¸¸éœ€è¦é‡è¿

**åŸå› åŠè§£å†³æ–¹æ¡ˆ**ï¼š

| å¯èƒ½åŸå›  | æ£€æŸ¥æ–¹æ³• | è§£å†³æ–¹æ¡ˆ |
|---------|---------|----------|
| `UpdateAsync()`æœªå®šæœŸè°ƒç”¨ | æ£€æŸ¥å·¥ä½œå™¨æ˜¯å¦æ­£å¸¸æ‰§è¡Œ | ç¡®ä¿å®šæœŸè°ƒç”¨UpdateAsync(æ¨è10ms) |
| æ—¶é—´æˆ³ä¸æ­£ç¡® | æ£€æŸ¥ä¸¤ç«¯æ—¶é—´æˆ³ç®—æ³• | ä½¿ç”¨`DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()` |
| ç½‘ç»œä¸¢åŒ…ä¸¥é‡ | ç›‘æ§é‡ä¼ æ¬¡æ•° | è°ƒæ•´`fastresend`å‚æ•°ï¼Œå¯ç”¨å¿«é€Ÿé‡ä¼  |
| çª—å£å¤§å°å¤ªå° | æ£€æŸ¥çª—å£ä½¿ç”¨ç‡ | å¢å¤§`SendWindowSize`å’Œ`RecvWindowSize` |
| MTUè®¾ç½®ä¸å½“ | æ£€æŸ¥æ•°æ®åŒ…åˆ†ç‰‡ | æ ¹æ®ç½‘ç»œç¯å¢ƒè°ƒæ•´MTU(é€šå¸¸1400ï¼Œæ ¹æ®ç½‘ç»œç‰¹æ€§è°ƒæ•´ï¼ˆèœ‚çªç½‘ç»œã€ä»¥å¤ªç½‘ç­‰ï¼‰) |

### Q9: é«˜å»¶è¿Ÿç¯å¢ƒæ€§èƒ½å·®
**ç°è±¡**ï¼šåœ¨é«˜å»¶è¿Ÿç½‘ç»œ(>100ms)ä¸­æ€§èƒ½æ˜¾è‘—ä¸‹é™

**è°ƒä¼˜å»ºè®®**ï¼š
```csharp
// é«˜å»¶è¿Ÿç½‘ç»œä¸“ç”¨é…ç½®
connection.ConfigureNoDelay(
    nodelay: true,     // å¯ç”¨æ— å»¶è¿Ÿæ¨¡å¼
    interval: 30,      // å¢åŠ æ›´æ–°é—´éš”
    resend: 3,         // é™ä½å¿«é€Ÿé‡ä¼ é˜ˆå€¼
    nc: false          // ä¿æŒæ‹¥å¡æ§åˆ¶
);

// å¢å¤§çª—å£ä»¥é€‚åº”é«˜å»¶è¿Ÿ
connection.SendWindowSize = 1024;
connection.RecvWindowSize = 1024;
```

## è°ƒè¯•å»ºè®®

### æ‰“å¼€EventSourceè¿½è¸ª
å‚è§[13_äº‹ä»¶è·Ÿè¸ªå‚è€ƒæ‰‹å†Œ.md](./13_äº‹ä»¶è·Ÿè¸ªå‚è€ƒæ‰‹å†Œ.md)

## å¸¸è§é”™è¯¯ä»£ç 

FaGe.Kcpåœ¨å†…éƒ¨å¤„ç†æ—¶å¯èƒ½è¿”å›ä»¥ä¸‹é”™è¯¯ç ï¼š

| é”™è¯¯ç  | å«ä¹‰ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|--------|------|----------|----------|
| **-1** | æ•°æ®åŒ…å¤ªçŸ­ | UDPæ•°æ®åŒ…å°äºKCPå¤´éƒ¨å¤§å°(24å­—èŠ‚) | æ£€æŸ¥å¯¹ç­‰ç«¯å®ç°ï¼Œä»¥åŠç¡®ä¿ä¼ è¾“å±‚å‘é€å®Œæ•´KCPæ•°æ®åŒ… |
| **-2** | æ„æ–™å¤–çš„CMD | å¯¹ç­‰ç«¯å‘é€äº†æ— æ•ˆçš„KCPå‘½ä»¤ | 1. åè®®ç‰ˆæœ¬ä¸åŒ¹é…<br>2. æ•°æ®æŸåæˆ–å—åˆ°æ”»å‡»<br>3. å¯¹ç­‰ç«¯ä¸æ˜¯æ ‡å‡†KCPå®ç° |
| **-3** | æœªçŸ¥å‘½ä»¤ | æ”¶åˆ°æ— æ³•è¯†åˆ«çš„å‘½ä»¤ç±»å‹ | æ£€æŸ¥å¯¹ç­‰ç«¯KCPå®ç°ï¼Œç¡®ä¿ä½¿ç”¨ç›¸åŒåè®®ç‰ˆæœ¬ |

## é¢„é˜²æªæ–½

### 1. è¿æ¥å»ºç«‹æ—¶éªŒè¯
```csharp
public async Task<bool> ValidateConnectionAsync(KcpConnection connection, TimeSpan timeout)
{
    using var cts = new CancellationTokenSource(timeout);
    
    try
    {
        // å‘é€æµ‹è¯•åŒ…
        var testData = Encoding.UTF8.GetBytes("TEST");
        var sendResult = await connection.SendAsync(testData, cts.Token);
        
        if (!sendResult.IsSucceed)
            return false;
        
        // ç­‰å¾…å“åº”ï¼ˆctså¸¦è¶…æ—¶ï¼‰
        var packet = await connection.ReceiveAsync(cts.Token)
            .WaitAsync(timeout, cts.Token);
        
        return packet.IsNotEmpty;
    }
    catch
    {
        return false;
    }
}
```

### 2. å®ç°å¥åº·æ£€æŸ¥
å¯ä»¥åœ¨ä¼ è¾“åè®®å¤„å®ç°å¥åº·æ£€æŸ¥ï¼ˆKCPåè®®ä½œè€…æ¨èæ–¹æ¡ˆï¼‰ï¼Œæˆ–åŸºäºKCPè¿æ¥å‘é€å¥åº·æ£€æŸ¥åŒ…ã€‚ä»¥ä¸‹æ˜¯åŸºäºKCPåè®®å‘é€å¥åº·æ£€æŸ¥çš„ç¤ºä¾‹ï¼š
```csharp
public class KcpHealthChecker
{
    private readonly KcpConnection _connection;
    private DateTime _lastActivity = DateTime.UtcNow;
    
    public KcpHealthChecker(KcpConnection connection)
    {
        _connection = connection;
    }
    
    public void RecordActivity() => _lastActivity = DateTime.UtcNow;
    
    public bool IsHealthy(TimeSpan timeout)
        => DateTime.UtcNow - _lastActivity < timeout;
    
    public async Task<bool> PerformHealthCheckAsync(CancellationToken ct)
    {
        try
        {
            // å‡è®¾å¯¹ç­‰ç«¯çŸ¥é“['P', 'I', 'N', 'G']: byte[4]æ˜¯å¥åº·æ£€æŸ¥
            var pingData = Encoding.UTF8.GetBytes("PING");
            await _connection.SendAsync(pingData, ct);
            
            var response = await _connection.ReceiveAsync(ct)
                .WaitAsync(TimeSpan.FromSeconds(3), ct);
            
            if (response.IsNotEmpty)
            {
                RecordActivity();
                return true;
            }
        }
        catch
        {
            // å¥åº·æ£€æŸ¥å¤±è´¥
        }
        
        return false;
    }
}
```

### 3. é…ç½®åˆç†çš„è¶…æ—¶å’Œé‡è¯•
```csharp
public class ResilientKcpClient
{
    private readonly Func<Task<KcpConnection>> _connectionFactory;
    private readonly int _maxRetries;
    private readonly TimeSpan _retryDelay;
    
    public async Task<TResult> ExecuteWithRetryAsync<TResult>(
        Func<KcpConnection, CancellationToken, Task<TResult>> operation,
        CancellationToken ct)
    {
        Exception lastException = null;
        
        for (int attempt = 0; attempt < _maxRetries; attempt++)
        {
            using var connection = await _connectionFactory();
            
            try
            {
                await operation(connection, ct);
				return;
            }
            catch (Exception ex) when (IsTransientError(ex))
            {
                lastException = ex;
                LogWarning($"å°è¯• {attempt + 1} å¤±è´¥: {ex.Message}");
                
                if (attempt < _maxRetries - 1)
                {
                    await Task.Delay(_retryDelay, ct);
                }
            }
        }
        
        throw new InvalidOperationException("æ‰€æœ‰é‡è¯•å°è¯•éƒ½å¤±è´¥", lastException);
    }
    
    private static bool IsTransientError(Exception ex)
        => ex is SocketException ||
           ex is TimeoutException ||
           ex is OperationCanceledException;
}
```

---
æœ¬æ–‡å®Œå…¨ç”±äººå·¥ç¼–å†™ï¼Œæ²¡æœ‰æœºå™¨äººå‚ä¸ğŸ¤–  
IPï¼šç”ŸåŒ–æ–¯å¦