# å¿«é€Ÿå¼€å§‹

## æœ€å°ç¤ºä¾‹
```csharp
using FaGe.Kcp;
using FaGe.Kcp.Connections;
using System.Net;
using System.Net.Sockets;

async Task RunKcpExampleAsync(CancellationToken ct)
{
    var udpClient = new UdpClient();
    var server = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8888);
    
    // è‡ªå®šä¹‰æ¡æ‰‹ï¼ˆå¯å‚è€ƒneuecc/kcpå®ç°ï¼‰
    uint conv = await HandshakeAsync(udpClient, server, ct);
    
    var connection = new KcpConnection(udpClient, conv, server);
    
    // ä½¿ç”¨Channelè¿›è¡Œçº¿ç¨‹å®‰å…¨çš„å‘é€ã€‚æ­¤å¤„ä¸ºç®€åŒ–ç¤ºä¾‹ã€‚å®è·µä¸Šå¯è€ƒè™‘ä¼ å…¥Func<KcpConnection, ValueTask>
    var sendChannel = System.Threading.Channels.Channel.CreateUnbounded<ReadOnlyMemory<byte>>();
    
    // å¯åŠ¨ä¸¤ä¸ªå¹¶è¡Œçš„ä»»åŠ¡
    var workerTask = KcpWorkerAsync(connection, sendChannel, ct);
    var sendProducerTask = SendProducerAsync(sendChannel, ct);
    
    // ç­‰å¾…ä»»åŠ¡å®Œæˆ
    await Task.WhenAll(workerTask, sendProducerTask);
}

// KCPå·¥ä½œå™¨ï¼šå¤„ç†æ‰€æœ‰KCPç›¸å…³æ“ä½œï¼ˆä¸²è¡Œæ‰§è¡Œï¼‰
async Task KcpWorkerAsync(
    KcpConnection connection,
    System.Threading.Channels.Channel<ReadOnlyMemory<byte>> sendChannel,
    CancellationToken ct)
{
    Task? udpReceiveTask = null;
    
    while (!ct.IsCancellationRequested)
    {
        try
        {
            // --- é˜¶æ®µ1ï¼šUDPè¾“å…¥å¤„ç† ---
            if (udpReceiveTask?.IsCompleted ?? false)
            {
                await udpReceiveTask.ConfigureAwait(false); // å¤„ç†åˆ°è¾¾çš„æ•°æ®
                udpReceiveTask = null;
            }
            
            if (udpReceiveTask == null)
            {
                // å¯åŠ¨æ–°çš„éé˜»å¡æ¥æ”¶
                udpReceiveTask = connection.ReceiveOnceAsync(ct);
            }
            
            // --- é˜¶æ®µ2ï¼šKCPçŠ¶æ€æ›´æ–° ---
            uint timestamp = (uint)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            await connection.UpdateAsync(timestamp, ct).ConfigureAwait(false);
            
            // --- é˜¶æ®µ3ï¼šå‘é€é˜Ÿåˆ—å¤„ç† ---
            while (sendChannel.Reader.TryRead(out var data))
            {
                try
                {
                    await connection.SendAsync(data, ct).ConfigureAwait(false);
                }
                catch (Exception ex) when (ex is not OperationCanceledException)
                {
                    // å‘é€å¤±è´¥æ—¶è®°å½•æ—¥å¿—ï¼Œç»ˆæ­¢è¿æ¥æ˜¯å¯æ¥å—çš„
                    LogError($"å‘é€å¤±è´¥ï¼Œç»ˆæ­¢KCPè¿æ¥: {ex.Message}");
                    throw; // è®©å¼‚å¸¸æµå‡ºå·¥ä½œå™¨
                }
            }
            
            // --- é˜¶æ®µ4ï¼šåº”ç”¨æ•°æ®æ¥æ”¶ ---
            var packet = connection.TryReadPacket(ct);
                
            if (packet.IsNotEmpty)
            {
                ProcessData(packet.Result.Buffer);
                packet.Dispose();
            }
            
            // --- é˜¶æ®µ5ï¼šå¾ªç¯æ§åˆ¶ ---
            // æ ¹æ®æ˜¯å¦æœ‰å·¥ä½œæ¥åŠ¨æ€è°ƒæ•´ç­‰å¾…æ—¶é—´
            bool hadWork = sendChannel.Reader.Count > 0;
            await Task.Delay(hadWork ? 1 : 10, ct).ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            // æ­£å¸¸é€€å‡º
            break;
        }
        catch (Exception ex)
        {
            // è®°å½•é”™è¯¯ï¼Œä½†ç»§ç»­è¿è¡Œï¼ˆé™¤éæ˜¯è‡´å‘½é”™è¯¯ï¼‰
            LogError($"KCPå·¥ä½œå™¨é”™è¯¯: {ex.Message}");
            await Task.Delay(100, ct).ConfigureAwait(false); // é”™è¯¯é€€é¿
        }
    }
    
    // æ¸…ç†ï¼šå–æ¶ˆä»»ä½•æŒ‚èµ·çš„æ¥æ”¶
    if (udpReceiveTask != null && !udpReceiveTask.IsCompleted)
    {
        try
        {
            await udpReceiveTask.WaitAsync(TimeSpan.FromMilliseconds(50), ct);
        }
        catch
        {
            // æ¸…ç†æœŸé—´çš„å¼‚å¸¸å¯å¿½ç•¥
        }
    }
}

// å‘é€ç”Ÿäº§è€…ï¼šç”¨æˆ·é€šè¿‡æ­¤æ–¹æ³•å‘é€æ•°æ®
async Task SendProducerAsync(
    System.Threading.Channels.Channel<ReadOnlyMemory<byte>> sendChannel,
    CancellationToken ct)
{
    int count = 0;
    while (!ct.IsCancellationRequested)
    {
        try
        {
            // ç¤ºä¾‹ï¼šæ¯ç§’å‘é€ä¸€æ¡æ¶ˆæ¯
            var message = $"Hello KCP {count++}";
            ReadOnlyMemory<byte> data = Encoding.UTF8.GetBytes(message);
            
            await sendChannel.Writer.WriteAsync(data, ct).ConfigureAwait(false);
            LogInfo($"å·²æ’é˜Ÿå‘é€: {message}");
            
            await Task.Delay(1000, ct).ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            break;
        }
        catch (Exception ex)
        {
            LogError($"å‘é€ç”Ÿäº§è€…é”™è¯¯: {ex.Message}");
            await Task.Delay(500, ct).ConfigureAwait(false); // é”™è¯¯é€€é¿
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async Task Main()
{
    var cts = new CancellationTokenSource();
    
    Console.CancelKeyPress += (s, e) =>
    {
        e.Cancel = true;
        cts.Cancel();
        Console.WriteLine("æ­£åœ¨åœæ­¢...");
    };
    
    try
    {
        await RunKcpExampleAsync(cts.Token);
        Console.WriteLine("æ­£å¸¸é€€å‡º");
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("ç”¨æˆ·å–æ¶ˆ");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"é”™è¯¯é€€å‡º: {ex.Message}");
    }
}
```

## è®¾è®¡è¯´æ˜

1. **å•å·¥ä½œå™¨çº¿ç¨‹**ï¼šæ‰€æœ‰KCPæ“ä½œåœ¨`KcpWorkerAsync`ä¸­é¡ºåºæ‰§è¡Œï¼Œé¿å…å¹¶å‘é—®é¢˜
2. **Channelçº¿ç¨‹å®‰å…¨**ï¼šå‘é€é€šè¿‡Channelå®ç°å¤šç”Ÿäº§è€…åˆ°å•æ¶ˆè´¹è€…çš„è½¬æ¢
3. **éé˜»å¡è®¾è®¡**ï¼š
   - UDPæ¥æ”¶ä½¿ç”¨"æ£€æŸ¥-ç­‰å¾…-æ¸…ç©º"æ¨¡å¼
   - åº”ç”¨æ¥æ”¶ä½¿ç”¨`TryReadPacket(CancellationToken)`éé˜»å¡æ£€æŸ¥
4. **é”™è¯¯æ¢å¤**ï¼šéè‡´å‘½é”™è¯¯è®°å½•åç»§ç»­è¿è¡Œ
5. **ä¼˜é›…åœæ­¢**ï¼šæ”¯æŒCtrl+Cå’Œç¨‹åºåŒ–å–æ¶ˆ

## å…³é”®ä¼˜åŠ¿

âœ… **æ— æ­»é”é£é™©**ï¼šä¸æŒæœ‰é”ç­‰å¾…å¼‚æ­¥æ“ä½œ  
âœ… **çº¿ç¨‹å®‰å…¨å‘é€**ï¼šé€šè¿‡Channelæ”¯æŒå¤šçº¿ç¨‹å‘é€  
âœ… **ç®€å•æ˜“æ‡‚**ï¼šä»£ç ç»“æ„æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œè°ƒè¯•  

## å¹¶è¡Œæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å‘é€ç”Ÿäº§è€…çº¿ç¨‹  â”‚â”€â”€â”€â”€â”€â–¶â”‚   Channelé˜Ÿåˆ—    â”‚
â”‚  (å¤šçº¿ç¨‹å®‰å…¨)   â”‚      â”‚   (çº¿ç¨‹å®‰å…¨)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚  KCPå·¥ä½œå™¨çº¿ç¨‹     â”‚
                         â”‚ (å•çº¿ç¨‹é¡ºåºæ‰§è¡Œ)   â”‚
                         â”‚ 1. UDPè¾“å…¥        â”‚
                         â”‚ 2. KCPæ›´æ–°        â”‚
                         â”‚ 3. å‘é€å¤„ç†       â”‚
                         â”‚ 4. åº”ç”¨æ¥æ”¶       â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

---
æœ¬æ–‡å®Œå…¨ç”±äººå·¥ç¼–å†™ï¼Œæ²¡æœ‰æœºå™¨äººå‚ä¸ğŸ¤–
IPï¼šç”ŸåŒ–æ–¯å¦