# è¿›é˜¶ç”¨æ³•

## è‡ªå®šä¹‰ä¼ è¾“å±‚å®ç°

FaGe.Kcpå…è®¸æ‚¨åˆ›å»ºè‡ªå®šä¹‰çš„ä¼ è¾“å±‚å®ç°ã€‚æ‰€æœ‰ä¼ è¾“å±‚éƒ½åº”è¯¥ç›´æ¥ç»§æ‰¿`KcpConnectionBase`ç±»ã€‚

### è®¾è®¡åŸåˆ™

1. **ä¸€å¯¹ä¸€ä¼ è¾“**ï¼ˆå¦‚WebSocketã€TCPï¼‰ï¼šå®ç°`ReceiveOnceAsync()`æ–¹æ³•
2. **å¤šè·¯å¤ç”¨ä¼ è¾“**ï¼ˆå¦‚UDPï¼‰ï¼šå®ç°`ManualInputOnce()`æ–¹æ³•
3. **å†…å­˜ä¼ è¾“**ï¼ˆæµ‹è¯•ç”¨ï¼‰ï¼šå®ç°å®Œæ•´çš„æ¨¡æ‹Ÿä¼ è¾“

### UDPè¿æ¥å®ç°ï¼ˆå·²æœ‰ï¼‰

```csharp
public sealed class KcpConnection : KcpConnectionBase
{
    private readonly UdpClient _udpTransport;
    public IPEndPoint RemoteEndpoint { get; set; }
    
    public KcpConnection(UdpClient udpTransport, uint connectionId, IPEndPoint remoteEndpoint) 
        : base(connectionId)
    {
        _udpTransport = udpTransport;
        RemoteEndpoint = remoteEndpoint;
    }
    
    protected override async ValueTask InvokeOutputCallbackAsync(
        ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
    {
        await _udpTransport.SendAsync(buffer, RemoteEndpoint, cancellationToken);
    }
    
    // è‡ªåŠ¨æ¥æ”¶æ¨¡å¼
    public async Task ReceiveOnceAsync(CancellationToken cancellationToken)
    {
        var result = await _udpTransport.ReceiveAsync(cancellationToken);
        var inputResult = InputFromUnderlyingTransport(result.Buffer);
        
        if (inputResult.IsFailed)
        {
            HandleInputFailure(inputResult, result.RemoteEndPoint);
        }
    }
    
    // æ‰‹åŠ¨è¾“å…¥æ¨¡å¼ï¼ˆç”¨äºæœåŠ¡å™¨å¤šè·¯å¤ç”¨ï¼‰
    public KcpInputResult ManualInputOnce(UdpReceiveResult receiveResult)
    {
        // æ£€æŸ¥ç«¯ç‚¹æ˜¯å¦åŒ¹é…
        if (!RemoteEndpoint.Equals(receiveResult.RemoteEndPoint))
        {
            RemoteEndpoint = receiveResult.RemoteEndPoint;
        }
        
        return InputFromUnderlyingTransport(receiveResult.Buffer);
    }
    
    private void HandleInputFailure(KcpInputResult inputResult, IPEndPoint remoteEndPoint)
    {
        switch (inputResult.RawResult)
        {
            case -1:
                Trace.WriteLine($"æ•°æ®åŒ…é•¿åº¦ä¸è¶³ from {remoteEndPoint}");
                break;
            case -2:
                Trace.WriteLine($"è¿æ¥æ ‡è¯†ä¸åŒ¹é… from {remoteEndPoint}");
                break;
            case -3:
                Trace.WriteLine($"æ„æ–™å¤–çš„CMD from {remoteEndPoint}");
                break;
        }
    }
}
```

### WebSocketä¼ è¾“å±‚

```csharp
/// <summary>
/// WebSocketçš„KCPè¿æ¥å®ç°
/// </summary>
/// <remarks>
/// æ¯ä¸ªWebSocketè¿æ¥å¯¹åº”ä¸€ä¸ªKCPè¿æ¥ï¼Œä¸æ”¯æŒå¤šè·¯å¤ç”¨
/// </remarks>
public sealed class WebSocketKcpConnection : KcpConnectionBase, IDisposable
{
    private readonly WebSocket _webSocket;
    private readonly ArrayPool<byte> _bufferPool;
    private readonly int _receiveBufferSize;
    private readonly IPEndPoint _logicalEndpoint;
    private bool _disposed;
    
    public IPEndPoint LogicalEndpoint => _logicalEndpoint;
    
    public WebSocketKcpConnection(
        uint conversationId, 
        WebSocket webSocket, 
        IPEndPoint logicalEndpoint,
        int receiveBufferSize = 4096) 
        : base(conversationId)
    {
        _webSocket = webSocket;
        _logicalEndpoint = logicalEndpoint;
        _bufferPool = ArrayPool<byte>.Shared;
        _receiveBufferSize = receiveBufferSize;
    }
    
    protected override async ValueTask InvokeOutputCallbackAsync(
        ReadOnlyMemory<byte> buffer, 
        CancellationToken cancellationToken)
    {
        if (_disposed || _webSocket.State != WebSocketState.Open)
            return;
            
        await _webSocket.SendAsync(
            buffer,
            WebSocketMessageType.Binary,
            endOfMessage: true,
            cancellationToken
        );
    }
    
    // WebSocketæ˜¯ä¸€å¯¹ä¸€è¿æ¥ï¼Œåªéœ€è¦è‡ªåŠ¨æ¨¡å¼
    public async Task ReceiveOnceAsync(CancellationToken cancellationToken)
    {
        if (_disposed || _webSocket.State != WebSocketState.Open)
            return;
            
        var buffer = _bufferPool.Rent(_receiveBufferSize);
        
        try
        {
            var receiveResult = await _webSocket.ReceiveAsync(buffer, cancellationToken);
            
            if (receiveResult.MessageType == WebSocketMessageType.Close)
            {
                await CloseAsync(cancellationToken);
                throw new InvalidOperationException("WebSocketè¿æ¥å·²å…³é—­");
            }
            
            if (receiveResult.MessageType != WebSocketMessageType.Binary)
            {
                throw new InvalidOperationException("åªæ”¯æŒäºŒè¿›åˆ¶æ¶ˆæ¯ç±»å‹");
            }
            
            // å¤åˆ¶æ•°æ®åˆ°æ­£ç¡®å¤§å°çš„æ•°ç»„
            var data = new byte[receiveResult.Count];
            Array.Copy(buffer, 0, data, 0, receiveResult.Count);
            
            var inputResult = InputFromUnderlyingTransport(data);
            
            if (inputResult.IsFailed)
            {
                HandleWebSocketInputFailure(inputResult);
            }
        }
        finally
        {
            _bufferPool.Return(buffer);
        }
    }
    
    // WebSocketä¸æ”¯æŒå¤šè·¯å¤ç”¨ï¼Œæ‰€ä»¥æ²¡æœ‰ManualInputOnceæ–¹æ³•
    
    public async ValueTask CloseAsync(CancellationToken cancellationToken)
    {
        if (_disposed)
            return;
            
        try
        {
            if (_webSocket.State == WebSocketState.Open)
            {
                await _webSocket.CloseAsync(
                    WebSocketCloseStatus.NormalClosure,
                    "KCP connection closed",
                    cancellationToken
                );
            }
        }
        finally
        {
            Dispose();
        }
    }
    
    private void HandleWebSocketInputFailure(KcpInputResult inputResult)
    {
        switch (inputResult.RawResult)
        {
            case -1:
                Trace.WriteLine($"WebSocketè¿æ¥ {ConnectionId} æ¥æ”¶æ•°æ®ä¸å®Œæ•´");
                break;
            case -2:
                Trace.WriteLine($"WebSocketè¿æ¥ {ConnectionId} æ ‡è¯†ç¬¦ä¸åŒ¹é…");
                break;
            case -3:
                Trace.WriteLine($"WebSocketè¿æ¥ {ConnectionId} æ”¶åˆ°æ— æ•ˆå‘½ä»¤");
                break;
        }
    }
    
    public void Dispose()
    {
        if (_disposed)
            return;
            
        _disposed = true;
        _webSocket.Dispose();
    }
}
```

### å†…å­˜ä¼ è¾“å±‚ï¼ˆæµ‹è¯•ç”¨ï¼‰

```csharp
/// <summary>
/// å†…å­˜æ¨¡æ‹Ÿçš„KCPè¿æ¥ï¼Œç”¨äºå•å…ƒæµ‹è¯•å’Œå¼€å‘
/// </summary>
/// <remarks>
/// é€šè¿‡MemoryTransportè¿æ¥ä¸¤ä¸ªInMemoryKcpConnectionå®ä¾‹
/// </remarks>
public sealed class InMemoryKcpConnection : KcpConnectionBase
{
    private readonly MemoryTransport _transport;
    private readonly object _endpoint;
    
    public object Endpoint => _endpoint;
    
    public InMemoryKcpConnection(uint conversationId, MemoryTransport transport, object endpoint) 
        : base(conversationId)
    {
        _transport = transport;
        _endpoint = endpoint;
    }
    
    protected override async ValueTask InvokeOutputCallbackAsync(
        ReadOnlyMemory<byte> buffer, 
        CancellationToken cancellationToken)
    {
        // é€šè¿‡å†…å­˜ä¼ è¾“å‘é€æ•°æ®
        await _transport.SendAsync(_endpoint, buffer, cancellationToken);
    }
    
    // è‡ªåŠ¨æ¥æ”¶æ¨¡å¼
    public async Task ReceiveOnceAsync(CancellationToken cancellationToken)
    {
        var (data, source) = await _transport.ReceiveAsync(_endpoint, cancellationToken);
        var inputResult = InputFromUnderlyingTransport(data);
        
        if (inputResult.IsFailed)
        {
            HandleInputFailure(inputResult);
        }
    }
    
    // æ‰‹åŠ¨è¾“å…¥æ¨¡å¼ï¼ˆç”¨äºé›†ä¸­å¼è·¯ç”±ï¼‰
    public KcpInputResult ManualInputOnce(ReadOnlyMemory<byte> data)
    {
        return InputFromUnderlyingTransport(data);
    }
    
    private void HandleInputFailure(KcpInputResult inputResult)
    {
        switch (inputResult.RawResult)
        {
            case -1:
                Trace.WriteLine($"å†…å­˜è¿æ¥ {ConnectionId} æ¥æ”¶æ•°æ®ä¸å®Œæ•´");
                break;
            case -2:
                Trace.WriteLine($"å†…å­˜è¿æ¥ {ConnectionId} æ ‡è¯†ç¬¦ä¸åŒ¹é…");
                break;
            case -3:
                Trace.WriteLine($"å†…å­˜è¿æ¥ {ConnectionId} æ”¶åˆ°æ— æ•ˆå‘½ä»¤");
                break;
        }
    }
}

/// <summary>
/// å†…å­˜ä¼ è¾“ï¼Œç”¨äºè¿æ¥ä¸¤ä¸ªInMemoryKcpConnectionå®ä¾‹
/// </summary>
public sealed class MemoryTransport : IDisposable
{
    private readonly ConcurrentDictionary<object, Channel<ReadOnlyMemory<byte>>> _channels = new();
    private readonly ConcurrentDictionary<object, object> _pairedConnections = new();
    
    public void Pair(object endpointA, object endpointB)
    {
        _pairedConnections[endpointA] = endpointB;
        _pairedConnections[endpointB] = endpointA;
        
        // ä¸ºæ¯ä¸ªç«¯ç‚¹åˆ›å»ºChannel
        _channels.GetOrAdd(endpointA, _ => Channel.CreateUnbounded<ReadOnlyMemory<byte>>());
        _channels.GetOrAdd(endpointB, _ => Channel.CreateUnbounded<ReadOnlyMemory<byte>>());
    }
    
    public async ValueTask SendAsync(object fromEndpoint, ReadOnlyMemory<byte> data, CancellationToken ct)
    {
        if (_pairedConnections.TryGetValue(fromEndpoint, out var toEndpoint))
        {
            if (_channels.TryGetValue(toEndpoint, out var channel))
            {
                await channel.Writer.WriteAsync(data, ct);
            }
        }
    }
    
    public async ValueTask<(ReadOnlyMemory<byte> data, object source)> ReceiveAsync(
        object forEndpoint, 
        CancellationToken ct)
    {
        if (_channels.TryGetValue(forEndpoint, out var channel))
        {
            var data = await channel.Reader.ReadAsync(ct);
            var source = _pairedConnections[forEndpoint];
            return (data, source);
        }
        
        throw new InvalidOperationException($"Endpoint not found: {forEndpoint}");
    }
    
    public void Dispose()
    {
        foreach (var channel in _channels.Values)
        {
            channel.Writer.TryComplete();
        }
        _channels.Clear();
        _pairedConnections.Clear();
    }
}
```

#### å†…å­˜ä¼ è¾“ä½¿ç”¨ç¤ºä¾‹

```csharp
// å•å…ƒæµ‹è¯•ï¼šå†…å­˜æ¨¡æ‹Ÿè¿æ¥
[Test]
public async Task TestInMemoryKcpConnection()
{
    var transport = new MemoryTransport();
    
    // åˆ›å»ºä¸¤ä¸ªç«¯ç‚¹
    var clientEndpoint = new object();
    var serverEndpoint = new object();
    
    // é…å¯¹è¿æ¥
    transport.Pair(clientEndpoint, serverEndpoint);
    
    // åˆ›å»ºä¸¤ä¸ªKCPè¿æ¥
    var clientConn = new InMemoryKcpConnection(1, transport, clientEndpoint);
    var serverConn = new InMemoryKcpConnection(1, transport, serverEndpoint);
    
    // é…ç½®è¿æ¥
    clientConn.ConfigureNoDelay(true, 10, 2, false);
    serverConn.ConfigureNoDelay(true, 10, 2, false);
    
    // æµ‹è¯•å‘é€å’Œæ¥æ”¶
    var sendData = Encoding.UTF8.GetBytes("Hello KCP");
    
    // å®¢æˆ·ç«¯å‘é€
    await clientConn.SendAsync(sendData, CancellationToken.None);
    
    // æœåŠ¡å™¨æ¥æ”¶
    var packet = await serverConn.ReceiveAsync(CancellationToken.None);
    Assert.IsTrue(packet.IsNotEmpty);
    Assert.AreEqual("Hello KCP", Encoding.UTF8.GetString(packet.Result.Buffer.ToArray()));
    packet.Dispose();
    
    transport.Dispose();
}
```

### ä½•æ—¶ä½¿ç”¨å“ªç§æ¨¡å¼ï¼Ÿ

| ä¼ è¾“ç±»å‹ | æ¨èæ¨¡å¼ | åŸå›  |
|---------|---------|------|
| **UDPæœåŠ¡å™¨** | `ManualInputOnce()` | å•ä¸ªUdpClientæœåŠ¡å¤šä¸ªè¿æ¥ï¼Œéœ€è¦æ‰‹åŠ¨è·¯ç”± |
| **UDPå®¢æˆ·ç«¯** | `ReceiveOnceAsync()` | æ¯ä¸ªè¿æ¥æœ‰è‡ªå·±çš„UdpClient |
| **WebSocket** | `ReceiveOnceAsync()` | ä¸€å¯¹ä¸€è¿æ¥ï¼Œä¸éœ€è¦å¤šè·¯å¤ç”¨ |
| **TCP** | `ReceiveOnceAsync()` | ä¸€å¯¹ä¸€è¿æ¥ |
| **æ¶ˆæ¯é˜Ÿåˆ—** | `ManualInputOnce()` | é›†ä¸­å¼æ¶ˆæ¯åˆ†å‘ |
| **å†…å­˜æµ‹è¯•** | ä¸¤ç§éƒ½å¯ | å–å†³äºæµ‹è¯•åœºæ™¯ |

### å®ç°è¦ç‚¹

1. **å¿…é¡»å®ç°** `InvokeOutputCallbackAsync()` æŠ½è±¡æ–¹æ³•
2. **å¯é€‰å®ç°** `ReceiveOnceAsync()` ç”¨äºè‡ªåŠ¨æ¥æ”¶
3. **å¯é€‰å®ç°** `ManualInputOnce()` ç”¨äºæ‰‹åŠ¨è¾“å…¥
4. **èµ„æºç®¡ç†** æ­£ç¡®å®ç° `IDisposable` æˆ– `IAsyncDisposable`
5. **ç«¯ç‚¹ç®¡ç†** æä¾›ç«¯ç‚¹ä¿¡æ¯ï¼Œæ”¯æŒç«¯ç‚¹å˜æ›´ï¼ˆå¦‚UDP NATé‡ç»‘å®šï¼‰

### æµ‹è¯•å»ºè®®

ä½¿ç”¨`InMemoryKcpConnection`è¿›è¡Œå•å…ƒæµ‹è¯•ï¼š
- æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿå’Œä¸¢åŒ…
- æµ‹è¯•åè®®äº¤äº’
- éªŒè¯èµ„æºç®¡ç†
- æ€§èƒ½åŸºå‡†æµ‹è¯•
---
æœ¬æ–‡å®Œå…¨ç”±äººå·¥ç¼–å†™ï¼Œæ²¡æœ‰æœºå™¨äººå‚ä¸ğŸ¤–
IPï¼šç”ŸåŒ–æ–¯å¦