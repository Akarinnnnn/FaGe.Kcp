# 并发安全性

## 线程安全级别

**重要**：FaGe.Kcp 的并发安全性有限，大多数核心方法**不是线程安全的**。这是为了性能和实现简易做出的设计权衡。

| 方法/属性 | 并发安全性 | 风险说明 |
|----------|-----------|----------|
| `SendAsync()` | ❌ 不安全 | 通过`QueueToSenderWithAsyncSource()`操作非线程安全的`snd_queue` |
| `ReceiveAsync()` | ❌ 不安全 | 底层`TryReadPacket()`操作非线程安全的`rcv_queue`，且`pendingReceiveTaskSource`存在竞争条件 |
| `UpdateAsync()` | ❌ 不安全 | 无任何同步措施，会修改内部连接状态（snd_queue、rcv_queue等） |
| `FlushAsync()` | ❌ 不安全 | 修改内部缓冲区状态 |
| `InputFromUnderlyingTransport()` | ❌ 不安全 | 修改接收队列和缓冲区 |
| `ReceiveOnceAsync()` | ❌ 不安全 | 调用`InputFromUnderlyingTransport()`，同样修改内部状态 |
| `ConfigureNoDelay()` | ⚠️ 读安全/写不安全 | 读取配置属性是安全的，但调用此方法修改配置与其他操作并发时存在风险 |
| `Dispose()` | ⚠️ 有限安全 | 可在任何线程调用，但若与其他操作并发，可能抛出`ObjectDisposedException` |
| `GetWhenShouldUpdate()` | ✅ 只读安全 | 仅读取状态，不修改 |
| `GetNextReceivedMessageSize()` | ✅ 只读安全 | 仅读取接收队列状态 |

## 有限支持的模式
- **`TryReadPacket()`**：有限支持多消费者，但必须保证顺序：`A读取包1 → A释放 → B读取包2 → B释放`
- **内部集合**：所有非并发集合（`Queue<T>`、`LinkedList<T>`）均无同步机制

## 事件处理线程安全

FaGe.Kcp 使用 `EventSource` 进行诊断跟踪，所有事件方法都是**线程安全的**：

```csharp
// ✅ 可在任何线程安全调用
KcpTraceEventSource.Log.KcpWindowFullStateChange(conv, isFull, rcvWnd, totalPackets, effectiveWindow);
```

**注意**：虽然事件方法本身是线程安全的，但传递给事件的参数（如从共享集合读取的值）可能存在竞争条件，事件记录的是调用瞬间的快照。

## 推荐的使用模式

### ✅ 正确模式：专用异步工作器（推荐）
```csharp
public async Task KcpWorkerAsync(
    KcpConnection connection,
    Channel<byte[]> sendChannel,
    CancellationToken ct)
{
    Task? udpReceiveTask = null;
    
    while (!ct.IsCancellationRequested)
    {
        try
        {
            // --- 阶段1：UDP输入处理 ---
            if (udpReceiveTask?.IsCompleted ?? false)
            {
                await udpReceiveTask.ConfigureAwait(false); // 处理到达的数据
                udpReceiveTask = null;
            }

            // --- 阶段2：KCP状态更新 ---
            uint timestamp = (uint)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            await connection.UpdateAsync(timestamp, ct).ConfigureAwait(false);
            
            if (udpReceiveTask == null)
            {
                // 启动新的非阻塞接收
                udpReceiveTask = connection.ReceiveOnceAsync(ct);
            }            
            
            // --- 阶段3：发送队列处理 ---
            while (sendChannel.Reader.TryRead(out var data))
            {
                await connection.SendAsync(data, ct).ConfigureAwait(false);
            }
            
            // --- 阶段4：应用数据接收 ---
            var packet = connection.TryReadPacket(ct);
            
            if (packet.IsNotEmpty)
            {
                ProcessData(packet.Result.Buffer);
                packet.Dispose();
            }
            
            // --- 阶段5：循环控制 ---
            // 根据是否有工作来动态调整等待时间
            bool hadWork = sendChannel.Reader.Count > 0;
            await Task.Delay(hadWork ? 1 : 10, ct).ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            // 正常退出
            break;
        }
        catch (Exception ex)
        {
            // 记录错误，但继续运行（除非是致命错误）
            LogError($"KCP工作器错误: {ex.Message}");
            await Task.Delay(100, ct).ConfigureAwait(false); // 错误退避
        }
    }
}
```

### ✅ 配置变更的正确模式
```csharp
// 所有配置变更应在工作器线程同步进行
public void UpdateConfiguration(KcpConnection connection, KcpConfig newConfig)
{
    // ❌ 错误：可能与其他操作并发
    // await Task.WhenAll(
    //     connection.ConfigureNoDelay(...),
    //     connection.SendAsync(data)
    // );
    
    // ✅ 正确：通过工作器通道发送配置变更请求
    await configChannel.WriteAsync(newConfig);
}

// 在工作器循环中处理
if (configChannel.Reader.TryRead(out var newConfig))
{
    connection.ConfigureNoDelay(
        newConfig.NoDelay,
        newConfig.Interval,
        newConfig.FastResend,
        newConfig.DisableCongestionControl
    );
}
```

## ReceiveOnceAsync() 的重要特性

### 1. 非幂等性
每个`ReceiveOnceAsync()`调用处理一个数据包，多次调用会处理不同的数据包。

### 2. 异步阻塞性
`ReceiveOnceAsync()`会等待直到有数据到达或取消，是异步阻塞操作。

### 3. 顺序敏感性
必须按顺序处理`ReceiveOnceAsync()`调用结果，避免多个未完成的调用导致数据包处理顺序错误。

## 已知的竞争条件

### 1. pendingReceiveTaskSource 竞争
```csharp
// 在 ReceiveAsyncBase 中：
pendingReceiveTaskSource = signalSource;

// 如果两个线程同时调用 ReceiveAsync()：
// 线程A: 设置 pendingReceiveTaskSource = sourceA
// 线程B: 设置 pendingReceiveTaskSource = sourceB （覆盖A）
// 结果：线程A的 TaskCompletionSource 可能永远无法完成
```

### 2. 集合操作竞争
```csharp
// 同时调用 SendAsync() 和 UpdateAsync()：
// SendAsync: snd_queue.Enqueue(packet)
// UpdateAsync: snd_queue.TryDequeue(out packet) // 可能同时发生，导致异常
```

### 3. ReceiveOnceAsync 并发调用竞争
```csharp
// 同时启动多个 ReceiveOnceAsync() 调用：
// 调用1: 开始接收数据包A
// 调用2: 开始接收数据包B
// 问题：两个调用可能并发修改内部状态，且数据包处理顺序不确定
```

### 4. Dispose与其他操作的竞争
```csharp
// 线程A: await connection.SendAsync(data, ct);
// 线程B: connection.Dispose();  // 可能立即触发ObjectDisposedException

// 解决方案：使用CancellationToken协调
// 所有操作都检查同一个CancellationToken（或至少链接至这个Token）
// Dispose前取消该token
```

## 异常处理原则

### 策略总结

| 异常类型 | 处理方式 | 理由 |
|---------|---------|------|
| `OperationCanceledException` (已知来源ct触发) | 捕获并`break` | 正常退出流程 |
| `SocketException` (超时/连接重置/网络变化等临时错误) | 捕获并继续 | 网络临时问题，可恢复 |
| `ObjectDisposedException` (取消时) | 捕获并`break` | 资源清理期间的预期异常 |
| **其他所有异常** | **不捕获，传播出去** | **让调用者感知严重错误** |

### 为什么让异常流出工作器？

1. **调用者知情权**：调用者需要知道工作器是否因错误退出
2. **监控和告警**：外部系统可以监控工作器故障
3. **资源管理**：如果工作器因异常退出，可能需要重建连接
4. **调试信息**：完整的异常堆栈有助于问题诊断

## 性能与安全权衡

FaGe.Kcp 设计时的权衡：

1. **性能优先**：使用标准集合而非并发集合，减少锁开销
2. **简单性**：避免复杂的同步逻辑，简化代码结构
3. **明确责任**：将并发安全的责任交给使用者，提供灵活性。但代价是提高了编写门槛
4. **异步友好**：移除后台循环，完全拥抱async/await模式
5. **诊断可观测性**：通过 EventSource 提供线程安全的诊断信息，帮助定位并发问题

## 并发问题诊断

### 使用 EventSource 检测并发问题

```csharp
// 通过观察事件序列，可以发现潜在的并发问题
// 正常序列（单线程）：
// KcpSendEnd → KcpFlush → KcpEmittingSinglePushPacket

// 异常序列（可能并发）：
// KcpSendEnd (线程A)
// KcpSendEnd (线程B)  // 同一连接并发发送
// KcpFlush (线程A)
// KcpFlush (线程B)    // 并发刷新导致状态混乱
```

### 推荐的诊断工具组合

1. **dotnet-trace** + **PerfView**：捕获 EventSource 事件
2. **自定义监听器**：在开发环境记录操作序列
3. **日志关联**：将 EventSource 事件与应用日志关联

## 最佳实践总结

1. **每个连接使用专用异步工作器**（如`KcpWorkerAsync`模式）
2. **使用"检查-等待-清空"模式管理`ReceiveOnceAsync()`调用**
3. **避免任何形式的并发方法调用**同一个连接实例
4. **让严重异常流出工作器**，使调用者能够感知和处理
5. **尽量避免启动后变更配置**，避免与数据操作并发
6. **谨慎使用`ConfigureAwait(false)`**：
   - ✅ **推荐在**：控制台应用、ASP.NET Core应用、后台服务、库代码中使用
   - ⚠️ **避免在**：ASP.NET（而不是Core）、WPF/WinForms UI线程等需要同步上下文的环境中盲目使用
   - **原则**：如果代码需要回到原始上下文（如更新UI、操作ASP.NET HttpContext），不要使用`ConfigureAwait(false)`
7. **正确处理异步异常**：
   ```csharp
   // ✅ 正确：保留原始异常堆栈
   try
   {
       await workerTask; // 异步等待获得原始异常
   }
   catch (Exception ex)
   {
       // ex包含完整的异步调用堆栈
   }
   ```
8. **服务端使用连接池**，每个连接有独立的异步工作器
9. **通过Task状态监控工作器健康**（`IsFaulted`、`Status`属性）
10. **利用 EventSource 诊断并发问题**，在开发和测试阶段启用详细跟踪

---
本文完全由人工编写，没有机器人参与🤖  
IP属地：生化斯坦